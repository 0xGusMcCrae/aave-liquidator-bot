dont worry about testnet, probably better off just trying to use a ganache
fork - but we'll see, there might be some good testnet stuff. It all depends
if there will be fake accounts that can be liqd on testnet. OR I can just
have the bot running on testnet, set up a separate account and get it 
liquidated on purpose. We'll see.  I gotta figure out how to do it anyway - 
i.e. might need to connect to the graph or whatever to get accounts data. 
At the very least need an event listener - which actually shouldn't be that 
hard and I'm pretty sure BTD had a section of event listening with brownie so 
we'll see. Either way, hopefully I can learn some shit.

This should be useful:
https://degencode.substack.com/p/event-listeners 

gonna need to get a websocket RPC for the event listener
this is available on alchemy

Also note that I could pretty easily switch this bot up to be able to 
run liquidations on just about any lending platform. And I wouldn't even
necessarily need to get my flashloans from anywhere else - could still
flashloan from aave to liquidate people on other platforms.

so for the event listeners we just want to listen to events and take down
addresses of the accounts that are interacting with the protocol. Once we have 
those accounts we can call getUserAccountData() from the pool contract to get
their health factor. And then just be cycling through to get notified when somebody
is below the health factor threshold. And of course need to run calculations to
ensure that liquidation is profitable.

might actuall be able to write my event listener logs to a csv and then
create a dataframe with pandas to be able to sort through and grab the 
account addresses easily

of course this is all dependent on the event listener staying connected for
long enough to get ANY events!

results of getUserAccountData:
totalCollateralBase - uint256 -total collateral of the user, in market’s base currency
totalDebtBase - uint256 - total debt of the user, in market’s base currency
availableBorrowsBase - uint256 - borrowing power left of the user, in market’s base currency
currentLiquidationThreshold - uint256 - liquidation threshold of the user
ltv - uint256 - Loan To Value of the user
healthFactor - uint256 - current health factor of the user

so we want the healthFactor to be below 1

Also need to figure out the account's debtToCover and debtAsset
can set debtToCover to uint(-1) to proceed with maximum allowable amount

once all this info is obtained:
    address of account below 1 HF 
    debtToCover
    debtAsset 
    collateralAsset
you can call liquidationCall (and execute the flashloan) to liquidate the user

gonna need to do (bytes1,bytes2) = l2encoder.encodeLiquidationCall(~~~~)